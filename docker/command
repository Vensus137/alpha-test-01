#!/bin/bash

# Универсальная команда для управления Docker контейнерами
# Использование: command [start|stop|restart|logs|status|update]

# Цвета для вывода
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Глобальные переменные для настройки команд
COMMAND_NAME="command"
COMMAND_DESCRIPTION="Command - Универсальное управление Docker контейнерами"

# Дефолтное имя контейнера (должно совпадать с DEFAULT_CONTAINER_NAME в core_updater.py)
DEFAULT_CONTAINER_NAME="coreness"

# Имя Docker образа
DOCKER_IMAGE="coreness-image"

# Кэш конфигурации
declare -A CONFIG_CACHE

# Пути к скриптам и файлам
TOOLS_DIR="tools/core"
DATABASE_MANAGER_SCRIPT="tools/database_manager.py"
CORE_UPDATER_SCRIPT="tools/core/core_updater.py"
DOCKER_COMPOSE_FILE="docker-compose.yml"
DOCKER_DIR="docker"
MAIN_SCRIPT="main.py"

# Настройки контейнера
CONTAINER_NAME="coreness-service"

# Дефолтные значения для настроек контейнера
DEFAULT_MEMORY_LIMIT=""
DEFAULT_CPU_LIMIT=""

# Шаблоны команд для создания алиасов
# Формат: command-<имя_команды>
ALIASES=("command-start" "command-stop" "command-restart" "command-logs" "command-status" "command-update" "command-db" "command-shell" "command-kill" "command-config")

# =============================================================================
# CONFIG MANAGER - Централизованное управление конфигурацией с кэшем
# =============================================================================

# Получить значение конфигурации с кэшированием
get_config() {
    local key="$1"
    local default_value="${2:-}"
    
    # Если значение уже в кэше - возвращаем его
    if [ -n "${CONFIG_CACHE[$key]:-}" ]; then
        echo "${CONFIG_CACHE[$key]}"
        return 0
    fi
    
    # Вычисляем значение в зависимости от ключа
    local computed_value=""
    case "$key" in
        "command_name")
            # Имя команды - всегда имя скрипта (для UI, алиасов, установки)
            computed_value=$(basename "$0")
            ;;
        "container_name")
            # Имя контейнера - определяется по имени команды (для Docker операций)
            local script_basename=$(basename "$0")
            if [ "$script_basename" != "command" ]; then
                # Если команда отличается от дефолтной - используем имя команды
                computed_value="$script_basename"
            else
                # Если команда дефолтная - используем дефолтное имя контейнера
                computed_value="$(get_default_container_name)"
            fi
            ;;
        "docker_image")
            # Пытаемся определить образ из существующего контейнера
            local container_name=$(get_config "container_name")
            if docker ps -a --filter "name=$container_name" | grep -q "$container_name" 2>/dev/null; then
                computed_value=$(docker inspect $container_name --format='{{.Config.Image}}' 2>/dev/null)
            fi
            # Если не удалось определить - используем дефолт
            if [ -z "$computed_value" ]; then
                computed_value="$(get_docker_image_default)"
            fi
            ;;
        "project_dir")
            # Определяем путь к проекту напрямую
            computed_value=""
            
            # Сначала проверяем путь через volume существующего контейнера
            local container_name=$(get_config "container_name")
            if docker ps -a --filter "name=$container_name" | grep -q "$container_name" 2>/dev/null; then
                computed_value=$(docker inspect $container_name 2>/dev/null | jq -r '.[0].Mounts[] | select(.Destination=="/workspace") | .Source' 2>/dev/null)
                if [ -n "$computed_value" ] && [ -d "$computed_value" ]; then
                    # Путь найден через volume
                    :
                else
                    computed_value=""
                fi
            fi
            
            # Если не найден через volume, ищем по файловой системе
            if [ -z "$computed_value" ]; then
                # Ищем в текущей директории и родительских
                local current_dir="$(pwd)"
                while [ "$current_dir" != "/" ]; do
                    if [ -f "$current_dir/$(get_docker_dir)/Dockerfile" ]; then
                        computed_value="$current_dir"
                        break
                    fi
                    current_dir="$(dirname "$current_dir")"
                done
                
                # Ищем в /opt
                if [ -z "$computed_value" ] && [ -d "/opt" ]; then
                    for dir in /opt/*; do
                        if [ -d "$dir" ] && [ -f "$dir/$(get_docker_dir)/Dockerfile" ]; then
                            computed_value="$dir"
                            break
                        fi
                    done
                fi
            fi
            
            # Если не найден - используем дефолт
            if [ -z "$computed_value" ]; then
                computed_value="$default_value"
            fi
            ;;
        "env_file")
            # Определяем путь к .env файлу
            local project_dir
            project_dir=$(get_config "project_dir")
            if [ -n "$project_dir" ] && [ -f "$project_dir/.env" ]; then
                computed_value="$project_dir/.env"
            else
                computed_value=""
            fi
            ;;
        "memory_limit")
            computed_value="${CONFIG_CACHE[memory_limit]:-$DEFAULT_MEMORY_LIMIT}"
            ;;
        "cpu_limit")
            computed_value="${CONFIG_CACHE[cpu_limit]:-$DEFAULT_CPU_LIMIT}"
            ;;
        "command_description")
            computed_value="$COMMAND_DESCRIPTION"
            ;;
        "default_container_name")
            computed_value="$DEFAULT_CONTAINER_NAME"
            ;;
        "docker_image_default")
            computed_value="$DOCKER_IMAGE"
            ;;
        "tools_dir")
            computed_value="$TOOLS_DIR"
            ;;
        "database_manager_script")
            computed_value="$DATABASE_MANAGER_SCRIPT"
            ;;
        "core_updater_script")
            computed_value="$CORE_UPDATER_SCRIPT"
            ;;
        "docker_compose_file")
            computed_value="$DOCKER_COMPOSE_FILE"
            ;;
        "docker_dir")
            computed_value="$DOCKER_DIR"
            ;;
        "main_script")
            computed_value="$MAIN_SCRIPT"
            ;;
        "container_name_default")
            computed_value="$CONTAINER_NAME"
            ;;
        *)
            # Для неизвестных ключей возвращаем дефолт
            computed_value="$default_value"
            ;;
    esac
    
    # Сохраняем в кэш и возвращаем
    CONFIG_CACHE[$key]="$computed_value"
    echo "$computed_value"
}

# Очистить кэш конфигурации (полезно при изменении настроек)
clear_config_cache() {
    CONFIG_CACHE=()
}

# Обновить конкретное значение в кэше
update_config_cache() {
    local key="$1"
    local value="$2"
    CONFIG_CACHE[$key]="$value"
    
    # Если обновляем настройки контейнера - сохраняем в файл
    if [ "$key" = "memory_limit" ] || [ "$key" = "cpu_limit" ]; then
        save_config_to_file
    fi
}

# Получить путь к файлу конфигурации для текущего проекта
get_config_file_path() {
    local container_name=$(get_container_name)
    echo "$HOME/.${container_name}_config"
}

# Загрузить конфигурацию из файла
load_config_from_file() {
    local config_file=$(get_config_file_path)
    if [ -f "$config_file" ]; then
        # Читаем файл и сразу сохраняем в кэш
        while IFS='=' read -r key value; do
            # Пропускаем комментарии и пустые строки
            if [[ "$key" =~ ^[[:space:]]*# ]] || [[ -z "$key" ]]; then
                continue
            fi
            
            case "$key" in
                "MEMORY_LIMIT")
                    CONFIG_CACHE[memory_limit]="$value"
                    ;;
                "CPU_LIMIT")
                    CONFIG_CACHE[cpu_limit]="$value"
                    ;;
            esac
        done < "$config_file"
        
        echo "✅ Загружена конфигурация из $config_file"
    else
        echo "ℹ️ Файл конфигурации $config_file не найден, используются значения по умолчанию"
    fi
}

# Сохранить конфигурацию в файл
save_config_to_file() {
    local config_file=$(get_config_file_path)
    local container_name=$(get_container_name)
    
    # Создаем файл конфигурации напрямую из кэша
    cat > "$config_file" << EOF
# Конфигурация для проекта $container_name
# Создано: $(date)
MEMORY_LIMIT="${CONFIG_CACHE[memory_limit]:-$DEFAULT_MEMORY_LIMIT}"
CPU_LIMIT="${CONFIG_CACHE[cpu_limit]:-$DEFAULT_CPU_LIMIT}"
EOF
    
    echo "✅ Конфигурация сохранена в $config_file"
}

# Удобные функции-обертки для часто используемых значений
get_command_name() { get_config "command_name"; }
get_container_name() { get_config "container_name"; }
get_docker_image() { get_config "docker_image"; }
get_project_dir() { get_config "project_dir"; }
get_env_file() { get_config "env_file"; }
get_memory_limit() { get_config "memory_limit"; }
get_cpu_limit() { get_config "cpu_limit"; }
get_command_description() { get_config "command_description"; }
get_default_container_name() { get_config "default_container_name"; }
get_docker_image_default() { get_config "docker_image_default"; }
get_tools_dir() { get_config "tools_dir"; }
get_database_manager_script() { get_config "database_manager_script"; }
get_core_updater_script() { get_config "core_updater_script"; }
get_docker_compose_file() { get_config "docker_compose_file"; }
get_docker_dir() { get_config "docker_dir"; }
get_main_script() { get_config "main_script"; }
get_container_name_default() { get_config "container_name_default"; }

# Показать всю текущую конфигурацию
show_config() {
    echo -e "${BLUE}📋 Текущая конфигурация:${NC}"
    echo -e "   Команда: $(get_config 'command_name' 'не определена')"
    echo -e "   Контейнер: $(get_config 'container_name' 'не определен')"
    echo -e "   Образ: $(get_config 'docker_image' 'не определен')"
    echo -e "   Проект: $(get_config 'project_dir' 'не найден')"
    echo -e "   .env файл: $(get_config 'env_file' 'не найден')"
    echo -e "   Лимит памяти: $(get_config 'memory_limit' 'без ограничений')"
    echo -e "   Лимит CPU: $(get_config 'cpu_limit' 'без ограничений')"
}

# Функция для проверки Docker
check_docker() {
    if ! command -v docker &> /dev/null; then
        echo -e "${RED}❌ Docker не установлен!${NC}"
        exit 1
    fi
    
    if ! docker info &> /dev/null; then
        echo -e "${RED}❌ Docker не запущен!${NC}"
        exit 1
    fi
}

# Функция для проверки проекта и перехода в директорию
ensure_project_dir() {
    local project_dir=$(get_project_dir)
    if [ -z "$project_dir" ]; then
        echo -e "${RED}❌ Проект не найден!${NC}"
        exit 1
    fi
    cd "$project_dir"
}

# Функция для выполнения docker compose команд
docker_compose() {
    docker compose -f docker/docker-compose.yml "$@"
}

# Функция для проверки и запуска контейнера если нужно
ensure_container_running() {
    local container_name=$(get_container_name)
    # Проверяем, существует ли контейнер (любой статус)
    if ! docker ps -a --filter "name=$container_name" | grep -q "$container_name"; then
        echo -e "${YELLOW}⚠️ Контейнер не найден, создаю...${NC}"
        run_container_with_config "Создание"
    elif ! docker ps --filter "name=$container_name" --filter "status=running" | grep -q "$container_name"; then
        echo -e "${YELLOW}⚠️ Контейнер остановлен, запускаю...${NC}"
        docker start "$container_name"
        echo -e "${GREEN}✅ Контейнер запущен${NC}"
    fi
}

# Функция для установки команд
install_commands() {
    local container_name="$1"  # Получаем имя контейнера как параметр
    
    # Если имя контейнера не указано, определяем через ConfigManager
    if [ -z "$container_name" ]; then
        container_name=$(get_container_name)
    fi

    # Никаких ручных обновлений не нужно!
    
    echo -e "${BLUE}================================${NC}"
    echo -e "${BLUE}   УСТАНОВКА ГЛОБАЛЬНЫХ КОМАНД  ${NC}"
    echo -e "${BLUE}================================${NC}"
    echo -e "${BLUE}   Контейнер: $container_name   ${NC}"
    echo -e "${BLUE}================================${NC}"
    
    # Проверяем права
    if [ "$EUID" -eq 0 ]; then
        echo -e "${YELLOW}⚠️ Запуск от root. Команды будут установлены глобально.${NC}"
        INSTALL_DIR="/usr/local/bin"
    else
        echo -e "${YELLOW}⚠️ Запуск от обычного пользователя. Команды будут установлены локально.${NC}"
        INSTALL_DIR="$HOME/.local/bin"
        
        # Создаем папку если не существует
        mkdir -p "$INSTALL_DIR"
        
        # Добавляем в PATH если не добавлен
        if ! echo "$PATH" | grep -q "$INSTALL_DIR"; then
            echo -e "${YELLOW}💡 Добавляем $INSTALL_DIR в PATH...${NC}"
            echo "export PATH=\"\$PATH:$INSTALL_DIR\"" >> "$HOME/.bashrc"
            echo "export PATH=\"\$PATH:$INSTALL_DIR\"" >> "$HOME/.profile"
            echo -e "${GREEN}✅ PATH обновлен. Перезапустите терминал или выполните: source ~/.bashrc${NC}"
        fi
    fi
    
    # Получаем путь к исходному скрипту
    # Если мы запущены из /usr/local/bin, ищем исходный скрипт в docker/
    if [ "$(dirname "${BASH_SOURCE[0]}")" = "/usr/local/bin" ]; then
        # Ищем проект через ConfigManager
        local project_dir=$(get_project_dir)
        if [ -n "$project_dir" ]; then
            SCRIPT_PATH="$project_dir/docker/command"
        else
            echo -e "${RED}❌ Не удалось найти исходный скрипт command${NC}"
            exit 1
        fi
    else
        # Если запущены из docker/, используем текущий скрипт
        SCRIPT_PATH="${BASH_SOURCE[0]}"
    fi
    
    # Удаляем старую команду если существует
    if [ -f "$INSTALL_DIR/$container_name" ]; then
        echo -e "${YELLOW}🔄 Обновляю существующую команду...${NC}"
        rm "$INSTALL_DIR/$container_name"
    fi
    
    # Копируем основной скрипт
    if cp "$SCRIPT_PATH" "$INSTALL_DIR/$container_name"; then
        chmod +x "$INSTALL_DIR/$container_name"
        
        echo -e "${GREEN}✅ Команда '$container_name' установлена${NC}"
    else
        echo -e "${RED}❌ Ошибка установки команды '$container_name'${NC}"
        exit 1
    fi
    
    # Создаем алиасы
    create_aliases
    
    echo -e "${GREEN}🎉 Глобальные команды установлены!${NC}"
    echo ""
    echo -e "${BLUE}Теперь вы можете использовать:${NC}"
    show_available_commands "$container_name"
}

# Функция для создания алиасов
create_aliases() {
    local container_name=$(get_container_name)
    echo -e "${YELLOW}🔗 Создание алиасов для контейнера '$container_name'...${NC}"
    
    # Создаем алиасы в .bashrc
    ALIAS_FILE="$HOME/.bashrc"
    
    # Удаляем старые алиасы для этого контейнера если есть
    if grep -q "# $container_name aliases" "$ALIAS_FILE" 2>/dev/null; then
        echo -e "${YELLOW}🔄 Обновляю существующие алиасы...${NC}"
        # Удаляем старые алиасы (от начала комментария до следующего комментария или конца файла)
        sed -i "/# $container_name aliases/,/^# [^$container_name]/{ /# $container_name aliases/d; /^# [^$container_name]/!d; }" "$ALIAS_FILE" 2>/dev/null || true
    fi
    
    # Добавляем новые алиасы
    echo "" >> "$ALIAS_FILE"
    echo "# $container_name aliases" >> "$ALIAS_FILE"
    
    # Создаем алиасы из массива
    for alias in "${ALIASES[@]}"; do
        # Извлекаем команду из алиаса (убираем префикс command-)
        command="${alias#command-}"
        # Создаем алиас с именем контейнера
        new_alias="${container_name}-${command}"
        echo "alias $new_alias='$container_name $command'" >> "$ALIAS_FILE"
    done
    
    echo -e "${GREEN}✅ Алиасы для контейнера '$container_name' созданы${NC}"
    echo -e "${CYAN}💡 Доступные алиасы: ${container_name}-start, ${container_name}-stop, ${container_name}-restart, и т.д.${NC}"
}

# Универсальная функция для запуска контейнера с текущими настройками
run_container_with_config() {
    local action="$1"  # start, restart, или другие действия
    
    echo -e "${YELLOW}🚀 $action контейнера...${NC}"
    
    # Получаем конфигурацию через ConfigManager
    local project_dir=$(get_project_dir)
    local env_file=$(get_env_file)
    local memory_limit=$(get_memory_limit)
    local cpu_limit=$(get_cpu_limit)
    local docker_image=$(get_docker_image)
    local container_name=$(get_container_name)
    
    if [ -z "$project_dir" ]; then
        echo -e "${RED}❌ Проект не найден!${NC}"
        echo -e "${YELLOW}💡 Убедитесь, что вы находитесь в папке проекта или установите переменную COMMAND_PROJECT_DIR${NC}"
        exit 1
    fi
    
    # Показываем текущие настройки если есть
    if [ -n "$memory_limit" ] || [ -n "$cpu_limit" ]; then
        echo -e "${BLUE}🔧 Применяемые настройки:${NC}"
        if [ -n "$memory_limit" ]; then
            echo -e "   Лимит памяти: $memory_limit"
        fi
        if [ -n "$cpu_limit" ]; then
            echo -e "   Лимит CPU: $cpu_limit"
        fi
    fi
    
    # Останавливаем существующий контейнер если есть
    if docker ps --filter "name=$container_name" | grep -q "$container_name"; then
        echo -e "${YELLOW}🛑 Останавливаю существующий контейнер...${NC}"
        docker stop $container_name
        docker rm $container_name
    fi
    
    # Собираем команду запуска
    local cmd=("docker" "run" "-d" "--name" "$container_name")
    
    # Добавляем лимиты если указаны
    if [ -n "$memory_limit" ]; then
        cmd+=("-m" "$memory_limit")
    fi
    if [ -n "$cpu_limit" ]; then
        cmd+=("--cpus" "$cpu_limit")
    fi
    
    # Добавляем остальные параметры
    # Автоматически загружаем .env если есть
    if [ -n "$env_file" ]; then
        cmd+=("--env-file" "$env_file")
        echo -e "${GREEN}✅ Найден .env файл, загружаем переменные окружения${NC}"
    else
        echo -e "${YELLOW}⚠️ .env файл не найден, запускаем без переменных окружения${NC}"
    fi
    
    cmd+=("-v" "$project_dir:/workspace")
    cmd+=("$docker_image")
    cmd+=("tail" "-f" "/dev/null")
    
    # Запускаем контейнер
    if "${cmd[@]}"; then
        echo -e "${GREEN}✅ Контейнер $action с текущими настройками${NC}"
        echo -e "${YELLOW}💡 Для запуска приложения используйте: $container_name app-start${NC}"
    else
        echo -e "${RED}❌ Ошибка $action контейнера${NC}"
        exit 1
    fi
}

# Функция для запуска контейнера
start_service() {
    ensure_container_running
}

# Универсальная функция для остановки контейнера
stop_service() {
    local container_name=$(get_container_name)
    echo -e "${YELLOW}🛑 Остановка контейнера...${NC}"
    
    if docker stop $container_name; then
        echo -e "${GREEN}✅ Контейнер остановлен${NC}"
    else
        echo -e "${RED}❌ Ошибка остановки контейнера${NC}"
        exit 1
    fi
}

# Универсальная функция для перезапуска контейнера
restart_service() {
    run_container_with_config "Перезапуск"
}

# Функция для запуска приложения в контейнере
start_app() {
    local container_name=$(get_container_name)
    echo -e "${YELLOW}📱 Запуск приложения в контейнере...${NC}"
    
    # Проверяем, что контейнер запущен
    ensure_container_running
    
    # Проверяем, работает ли приложение уже
    if docker exec $container_name pgrep -f "python3 $(get_main_script)" > /dev/null; then
        echo -e "${GREEN}✅ Приложение уже работает${NC}"
    else
        # Запускаем main.py
        if docker exec -d $container_name python3 $(get_main_script); then
            echo -e "${GREEN}✅ Приложение запущено${NC}"
        else
            echo -e "${RED}❌ Ошибка запуска приложения${NC}"
            echo -e "${YELLOW}💡 Проверьте логи: $container_name logs${NC}"
            exit 1
        fi
    fi
}

# Функция для остановки приложения в контейнере
stop_app() {
    local container_name=$(get_container_name)
    echo -e "${YELLOW}🛑 Остановка приложения в контейнере...${NC}"
    
    # Проверяем, что контейнер запущен
    if ! docker ps --filter "name=$container_name" --filter "status=running" | grep -q "$container_name"; then
        echo -e "${RED}❌ Контейнер не запущен!${NC}"
        exit 1
    fi
    
    # Проверяем, есть ли процессы приложения
    PROCESSES=$(docker exec $container_name pgrep -f "python3 $(get_main_script)")
    if [ -z "$PROCESSES" ]; then
        echo -e "${YELLOW}⚠️ Приложение не запущено${NC}"
        return 0
    fi
    
    echo -e "${YELLOW}📋 Найдены процессы: $PROCESSES${NC}"
    
    # Сначала пытаемся мягко остановить (SIGTERM)
    echo -e "${YELLOW}🔄 Отправка SIGTERM...${NC}"
    docker exec $container_name pkill -f "python3 $(get_main_script)"
    
    # Ждем 3 секунды
    sleep 3
    
    # Проверяем, остановились ли процессы
    REMAINING=$(docker exec $container_name pgrep -f "python3 $(get_main_script)")
    if [ -n "$REMAINING" ]; then
        echo -e "${YELLOW}⚠️ Процессы не остановились, отправка SIGKILL...${NC}"
        docker exec $container_name pkill -9 -f "python3 $(get_main_script)"
        sleep 1
    fi
    
    # Финальная проверка
    FINAL_CHECK=$(docker exec $container_name pgrep -f "python3 $(get_main_script)")
    if [ -z "$FINAL_CHECK" ]; then
        echo -e "${GREEN}✅ Приложение остановлено${NC}"
    else
        echo -e "${RED}❌ Не удалось остановить приложение${NC}"
        echo -e "${YELLOW}💡 Оставшиеся процессы: $FINAL_CHECK${NC}"
        exit 1
    fi
}

# Функция для перезапуска приложения в контейнере
restart_app() {
    local container_name=$(get_container_name)
    echo -e "${YELLOW}🔄 Перезапуск приложения в контейнере...${NC}"
    
    # Проверяем, что контейнер запущен
    if ! docker ps --filter "name=$container_name" --filter "status=running" | grep -q "$container_name"; then
        echo -e "${YELLOW}⚠️ Контейнер не запущен, запускаю...${NC}"
        run_container_with_config "Запуск"
    fi
    
    # Убиваем все процессы main.py в контейнере
    echo -e "${YELLOW}🛑 Остановка приложения...${NC}"
    docker exec $container_name pkill -f "python3 $(get_main_script)" 2>/dev/null || true
    
    # Ждем немного, чтобы процессы завершились
    sleep 2
    
    # Запускаем main.py заново
    echo -e "${YELLOW}📱 Запуск приложения...${NC}"
    if docker exec -d $container_name python3 $(get_main_script); then
        echo -e "${GREEN}✅ Приложение перезапущено${NC}"
    else
        echo -e "${RED}❌ Ошибка перезапуска приложения${NC}"
        echo -e "${YELLOW}💡 Проверьте логи: $container_name logs${NC}"
        exit 1
    fi
}

# Функция для просмотра логов приложения (файл)
show_app_logs() {
    local container_name=$(get_container_name)
    echo -e "${YELLOW}📋 Просмотр логов приложения...${NC}"
    
    # Проверяем, что контейнер запущен
    if ! docker ps --filter "name=$container_name" --filter "status=running" | grep -q "$container_name"; then
        echo -e "${YELLOW}⚠️ Контейнер не запущен, запускаю...${NC}"
        run_container_with_config "Запуск"
    fi
    
    # Получаем количество строк (по умолчанию 10)
    local lines=${1:-10}
    
    # Проверяем, что это число
    if ! [[ "$lines" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}❌ Количество строк должно быть числом!${NC}"
        echo -e "${YELLOW}💡 Использование: $container_name app-logs [количество_строк]${NC}"
        exit 1
    fi
    
    echo -e "${YELLOW}📋 Показываю последние $lines строк логов...${NC}"
    
    # Показываем логи приложения из файла
    docker exec $container_name tail -f -n $lines /workspace/logs/bot.log
}

# Универсальная функция для просмотра логов контейнера
show_logs() {
    local container_name=$(get_container_name)
    docker logs -f $container_name
}

# Универсальная функция для проверки статуса
show_status() {
    local container_name=$(get_container_name)
    echo -e "${BLUE}📊 Статус контейнера:${NC}"
    docker ps --filter "name=$container_name"
    
    echo -e "\n${BLUE}📱 Статус приложения:${NC}"
    if docker exec $container_name pgrep -f "python3 $(get_main_script)" > /dev/null 2>&1; then
        # Получаем информацию о процессе
        PROCESS_INFO=$(docker exec $container_name ps aux | grep "python3 $(get_main_script)" | grep -v grep)
        if [ -n "$PROCESS_INFO" ]; then
            PID=$(echo "$PROCESS_INFO" | awk '{print $2}')
            CPU=$(echo "$PROCESS_INFO" | awk '{print $3}')
            MEM=$(echo "$PROCESS_INFO" | awk '{print $4}')
            TIME=$(echo "$PROCESS_INFO" | awk '{print $10}')
            echo -e "${GREEN}✅ Приложение работает${NC}"
            echo -e "   PID: $PID | CPU: $CPU% | MEM: $MEM% | TIME: $TIME"
        else
            echo -e "${YELLOW}⚠️ Процесс найден, но информация недоступна${NC}"
        fi
    else
        echo -e "${RED}❌ Приложение не запущено${NC}"
        echo -e "${YELLOW}💡 Запустите: $container_name start${NC}"
    fi
    
    echo -e "\n${BLUE}📈 Использование ресурсов контейнера:${NC}"
    docker stats --no-stream $container_name 2>/dev/null || echo "Контейнер не запущен"
}

# Функция для работы с БД
manage_app_database() {
    local container_name=$(get_container_name)
    echo -e "${YELLOW}🗄 Работа с базой данных...${NC}"
    
    # Проверяем, что контейнер запущен
    if ! docker ps --filter "name=$container_name" --filter "status=running" | grep -q "$container_name"; then
        echo -e "${YELLOW}⚠️ Контейнер не запущен, запускаю...${NC}"
        run_container_with_config "Запуск"
    fi
    
    # Запускаем database_manager.py с переданными параметрами
    shift  # Убираем первый аргумент (app-db)
    docker exec $container_name python3 $(get_database_manager_script) "$@"
}

# Универсальная функция для запуска shell в контейнере
open_shell() {
    local container_name=$(get_container_name)
    echo -e "${YELLOW}🐚 Запуск shell в контейнере...${NC}"
    
    # Проверяем, что контейнер запущен
    ensure_container_running
    
    # Запускаем bash в контейнере
    docker exec -it $container_name bash
}

# Функция для обновления приложения
update_app() {
    echo -e "${YELLOW}🔄 Обновление $(get_command_description)...${NC}"
    
    # Для обновления все-таки нужен доступ к файлам проекта
    local project_dir=$(get_project_dir)
    if [ -z "$project_dir" ]; then
        echo -e "${RED}❌ Проект не найден!${NC}"
        echo -e "${YELLOW}💡 Убедитесь, что вы находитесь в папке проекта или установите переменную COMMAND_PROJECT_DIR${NC}"
        exit 1
    fi
    
    # Запускаем core_updater.py
    python3 "$project_dir/$(get_core_updater_script)"
}

# Универсальная функция для установки настроек
set_container_config() {
    local container_name=$(get_container_name)
    # Убираем первый аргумент (config)
    shift
    
    # Обрабатываем все переданные параметры
    while [ $# -gt 0 ]; do
        local param="$1"
        shift
        
        case "$param" in
            "memory")
                if [ $# -eq 0 ]; then
                    echo -e "${RED}❌ Укажите лимит памяти!${NC}"
                    echo -e "${YELLOW}💡 Использование: $container_name config memory 512m${NC}"
                    exit 1
                fi
                
                local value="$1"
                shift
                
                # Проверяем формат памяти
                if ! [[ "$value" =~ ^[0-9]+[mg]?$ ]]; then
                    echo -e "${RED}❌ Неверный формат памяти!${NC}"
                    echo -e "${YELLOW}💡 Используйте: 512m, 1g, 2g${NC}"
                    exit 1
                fi
                
                update_config_cache "memory_limit" "$value"  # Обновляем только нужное значение в кэше
                echo -e "${GREEN}✅ Лимит памяти установлен: $value${NC}"
                ;;
                
            "cpu")
                if [ $# -eq 0 ]; then
                    echo -e "${RED}❌ Укажите лимит CPU!${NC}"
                    echo -e "${YELLOW}💡 Использование: $container_name config cpu 1.0${NC}"
                    exit 1
                fi
                
                local value="$1"
                shift
                
                # Проверяем формат CPU
                if ! [[ "$value" =~ ^[0-9]+\.?[0-9]*$ ]]; then
                    echo -e "${RED}❌ Неверный формат CPU!${NC}"
                    echo -e "${YELLOW}💡 Используйте: 0.5, 1.0, 2.0${NC}"
                    exit 1
                fi
                
                update_config_cache "cpu_limit" "$value"  # Обновляем только нужное значение в кэше
                echo -e "${GREEN}✅ Лимит CPU установлен: $value${NC}"
                ;;
                
            "reset")
                update_config_cache "memory_limit" "$DEFAULT_MEMORY_LIMIT"  # Сбрасываем к дефолтным значениям
                update_config_cache "cpu_limit" "$DEFAULT_CPU_LIMIT"
                echo -e "${GREEN}✅ Все лимиты сброшены к значениям по умолчанию${NC}"
                ;;
                
            *)
                echo -e "${RED}❌ Неизвестный параметр: $param${NC}"
                echo -e "${YELLOW}💡 Доступные параметры: memory, cpu, reset${NC}"
                echo -e "${YELLOW}💡 Использование: $container_name config [memory|cpu|reset] [значение]${NC}"
                exit 1
                ;;
        esac
    done
    
    echo -e "${YELLOW}🔄 Для применения выполните: $container_name restart${NC}"
}

# Универсальная функция для экстренной остановки
emergency_stop() {
    echo -e "${RED}💀 KILL ALL DOCKER${NC}"
    echo -e "${YELLOW}⚠️ Убиваю ВСЕ Docker процессы!${NC}"
    echo ""
    
    # Остановить все контейнеры
    echo -e "${YELLOW}🛑 Останавливаю контейнеры...${NC}"
    docker stop $(docker ps -q) 2>/dev/null || echo "Нет контейнеров"
    
    # Удалить все контейнеры
    echo -e "${YELLOW}🗑 Удаляю контейнеры...${NC}"
    docker rm $(docker ps -aq) 2>/dev/null || echo "Нет контейнеров"
    
    # Остановить Docker сервис
    echo -e "${YELLOW}⏹ Останавливаю Docker...${NC}"
    sudo systemctl stop docker 2>/dev/null || echo "Docker остановлен"
    
    # Убить все процессы Docker
    echo -e "${YELLOW}💀 Убиваю процессы...${NC}"
    sudo pkill -f docker 2>/dev/null || echo "Нет процессов"
    
    echo -e "${GREEN}✅ ВСЕ УБИТО!${NC}"
    echo -e "${YELLOW}💡 Запуск: sudo systemctl start docker${NC}"
}

# Функция для отображения доступных команд
show_available_commands() {
    local prefix="${1:-}"  # Префикс команды (пустой по умолчанию)
    prefix="${prefix:+$prefix }"  # Добавляем пробел только если префикс есть
    
    echo "  ${prefix}install         ${prefix:+# }Установить глобальные команды"
    echo "  ${prefix}start           ${prefix:+# }Запустить контейнер с текущими настройками"
    echo "  ${prefix}stop            ${prefix:+# }Остановить контейнер"
    echo "  ${prefix}restart         ${prefix:+# }Перезапустить контейнер"
    echo "  ${prefix}app-start       ${prefix:+# }Запустить приложение в контейнере"
    echo "  ${prefix}app-stop        ${prefix:+# }Остановить приложение в контейнере"
    echo "  ${prefix}app-restart     ${prefix:+# }Перезапустить приложение в контейнере"
    echo "  ${prefix}app-update      ${prefix:+# }Обновить приложение"
    echo "  ${prefix}app-db          ${prefix:+# }Работа с базой данных"
    echo "  ${prefix}app-logs [N]    ${prefix:+# }Показать логи приложения (файл, N строк)"
    echo "  ${prefix}logs            ${prefix:+# }Показать логи контейнера"
    echo "  ${prefix}status          ${prefix:+# }Показать статус контейнера"
    echo "  ${prefix}shell           ${prefix:+# }Запустить shell в контейнере"
    echo "  ${prefix}kill            ${prefix:+# }💀 Убить ВСЕ Docker процессы"
    echo ""
    echo "Настройки контейнера:"
    echo "  ${prefix}config show     ${prefix:+# }Показать текущие настройки"
    echo "  ${prefix}config memory   ${prefix:+# }Установить лимит памяти (512m, 1g)"
    echo "  ${prefix}config cpu      ${prefix:+# }Установить лимит CPU (0.5, 1.0)"
    echo "  ${prefix}config reset    ${prefix:+# }Сбросить все лимиты к дефолтным"
    echo "  ${prefix}help            ${prefix:+# }Показать эту справку"
}

# Универсальная функция для показа справки
show_help() {
    local container_name=$(get_container_name)
    echo -e "${BLUE}$(get_command_description)${NC}"
    echo ""
    echo "Использование: $container_name [команда] [параметры]"
    echo ""
    echo "Команды:"
    show_available_commands
    echo ""
    echo "Примеры:"
    echo "  $container_name start                             # Запустить контейнер"
    echo "  $container_name restart                           # Применить настройки"
    echo "  $container_name app-start                         # Запустить приложение"
    echo "  $container_name app-logs 50                       # Логи приложения (50 строк)"
    echo "  $container_name app-db --all --migrate            # Миграция БД"
    echo "  $container_name config cpu 1.0                    # Установить лимит CPU"
    echo "  $container_name config memory 512m cpu 0.5        # Установить оба лимита"
    echo "  $container_name config reset                      # Сбросить лимиты"

}

# Основная логика
main() {
    # Никаких ручных обновлений не нужно!
    
    # Для команды install не проверяем Docker
    if [ "$1" = "install" ]; then
        install_commands "$2"  # Передаем второй параметр как имя контейнера
        exit 0
    fi
    
    # Загружаем конфигурацию из файла (если есть)
    load_config_from_file
    
    # Для остальных команд проверяем Docker
    check_docker
    
    case "${1:-help}" in
        start)
            start_service
            ;;
        stop)
            stop_service
            ;;
        restart)
            restart_service
            ;;
        app-start)
            start_app
            ;;
        app-stop)
            stop_app
            ;;
        app-restart)
            restart_app
            ;;
        app-logs)
            show_app_logs "$2"
            ;;
        logs)
            show_logs
            ;;
        status)
            show_status
            ;;
        app-db)
            manage_app_database "$@"
            ;;
        shell)
            open_shell
            ;;
        app-update)
            update_app
            ;;
        kill)
            emergency_stop
            ;;
        # Команды для управления настройками
        config)
            if [ "$2" = "show" ]; then
                show_config
            else
                set_container_config "$@"
            fi
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            echo -e "${RED}❌ Неизвестная команда: $1${NC}"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

# Запуск
main "$@"
